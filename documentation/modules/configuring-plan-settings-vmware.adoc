// Module included in the following assemblies:
//
// * documentation/doc-Planning_your_migration/assemblies/assembly_planning-migration-vmware.adoc

:_mod-docs-content-type: PROCEDURE
[id="configuring-plan-settings-vmware_{context}"]
= Configuring VMware migration plan settings

[role="_abstract"]
After you create a migration plan using the {project-full} wizard, the *Plan details* page opens. This page contains important settings that do not appear in the wizard but can affect your migration. You can configure these settings immediately after creating the plan or return to configure them later before running the plan.

.Prerequisites

* You have created a migration plan using the {project-full} wizard. For more information, see xref:creating-plan-wizard-vmware_{context}[Creating a VMware vSphere migration plan by using the MTV wizard].

.Procedure

. On the *Plan details* page for your plan, review the *Plan settings* section.
+
The *Plan settings* section includes settings that you specified in the *Other settings (optional)* page of the wizard and some additional optional settings. The steps below refer to the additional optional settings, but all of the settings can be edited by clicking the {kebab}, making the change, and then clicking *Save*.

. Check the following items in the *Plan settings* section of the page:

.. *Volume name template*: Specifies a template for the volume interface name for the VMs in your plan.
+
The template follows the Go template syntax and has access to the following variables:

** `.PVCName`: Name of the PVC mounted to the VM using this volume
** `.VolumeIndex`: Sequential index of the volume interface (0-based)
+
Examples

** `"disk-{{.VolumeIndex}}"`
** `"pvc-{{.PVCName}}"`
+
Variable names cannot exceed 63 characters.
+
** To specify a volume name template for all the VMs in your plan, do the following:

*** Click the *Edit* icon.
*** Click *Enter custom naming template*.
*** Enter the template according to the instructions. Be sure that your template generates VM names that follow RFC 1123, but do not include uppercase letters.
*** Click *Save*.

** To specify a different volume name template only for specific VMs, do the following:

*** Click the *Virtual Machines* tab.
*** Select the desired VMs.
*** Click the {kebab} of the VM.
*** Select *Edit Volume name template*.
*** Enter the template according to the instructions. Be sure that your template generates VM names that follow RFC 1123, but do not include uppercase letters.
*** Click *Save*.
+
[IMPORTANT]
====
Changes you make on the *Virtual Machines* tab override any changes on the *Plan details* page.
====
+

.. *PVC name template*: Specifies a template for the name of the persistent volume claim (PVC) for the VMs in your plan.
+
The template follows the Go template syntax and has access to the following variables:

** `.VmName`: Name of the VM
** `.PlanName`: Name of the migration plan
** `.DiskIndex`: Initial volume index of the disk
** `.RootDiskIndex`: Index of the root disk
+
Examples

** `"{{.VmName}}-disk-{{.DiskIndex}}"`
** `"{{if eq .DiskIndex .RootDiskIndex}}root{{else}}data{{end}}-{{.DiskIndex}}"`
+
Variable names cannot exceed 63 characters.
+
** To specify a PVC name template for all the VMs in your plan, do the following:

*** Click the *Edit* icon.
*** Click *Enter custom naming template*.
*** Enter the template according to the instructions. Be sure that your template generates VM names that follow RFC 1123, but do not include uppercase letters.
*** Click *Save*.

** To specify a PVC name template only for specific VMs, do the following:

*** Click the *Virtual Machines* tab.
*** Select the desired VMs.
*** Click the {kebab} of the VM.
*** Select *Edit PVC name template*.
*** Enter the template according to the instructions. Be sure that your template generates VM names that follow RFC 1123, but do not include uppercase letters.
*** Click *Save*.
+
[IMPORTANT]
====
Changes you make on the *Virtual Machines* tab override any changes on the *Plan details* page.
====

.. *Network name template*: Specifies a template for the network interface name for the VMs in your plan.
+
The template follows the Go template syntax and has access to the following variables:

** `.NetworkName:` If the target network is `multus`, add the name of the Multus Network Attachment Definition. Otherwise, leave this variable empty.
** `.NetworkNamespace`: If the target network is `multus`, add the namespace where the Multus Network Attachment Definition is located.
** `.NetworkType`: Network type. Options: `multus` or `pod`.
** `.NetworkIndex`: Sequential index of the network interface (0-based).
+
Examples

** `"net-{{.NetworkIndex}}"`
** `{{if eq .NetworkType "pod"}}pod{{else}}multus-{{.NetworkIndex}}{{end}}"`
+
Variable names cannot exceed 63 characters.
+
** To specify a network name template for all the VMs in your plan, do the following:

*** Click the *Edit* icon.
*** Click *Enter custom naming template*.
*** Enter the template according to the instructions. Be sure that your template generates VM names that follow RFC 1123, but do not include uppercase letters.
*** Click *Save*.

** To specify a different network name template only for specific VMs, do the following:

*** Click the *Virtual Machines* tab.
*** Select the desired VMs.
*** Click the {kebab} of the VM.
*** Select *Edit Network name template*.
*** Enter the template according to the instructions. Be sure that your template generates VM names that follow RFC 1123, but do not include uppercase letters.
*** Click *Save*.
+
[IMPORTANT]
====
Changes you make on the *Virtual Machines* tab override any changes on the *Plan details* page.
====
+
[IMPORTANT]
====
{project-short} does not validate VM names generated by the templates you enter on the *Plan details* page. Migrations that include VMs whose names include uppercase letters or that violate RFC 1123 rules fail automatically. To avoid failures, you might want to run a Go script that uses the `sprig` methods that {project-short} supports. For tables documenting the methods that {project-short} supports, see {mtv-mig}assembly_migrating-from-vmware#mtv-template-utility_vmware[{project-short} template utility for {vmw} VM names].
====

.. *Raw copy mode*: By default, during migration, virtual machines (VMs) are converted using a tool named `virt-v2v` that makes them compatible with {virt}. For more information about the virt-v2v conversion process, see link:{mtv-mig}assembly_troubleshooting-migration_mtv#virt-v2v-mtv_mtv[How {project-short} uses the virt-v2v tool]. _Raw copy mode_ copies VMs without converting them. This allows for faster conversions, migrating VMs running a wider range of operating systems, and supporting migrating disks encrypted using Linux Unified Key Setup (LUKS) without needing keys. However, VMs migrated using raw copy mode might not function properly on {virt}.

** To use raw copy mode for your migration plan, do the following:
*** Click the *Edit* icon.
*** Toggle the *Raw copy mode* switch to enable it.
*** Optional: Configure the *Use compatibility mode* setting:
+
When you enable *Use compatibility mode* (default), {project-short} uses compatibility devices (SATA bus, E1000E NICs, USB) to ensure the VM can boot on {virt}.
+
When you disable *Use compatibility mode*, {project-short} uses pre-installed VirtIO devices on the source VM for better performance.
+
[IMPORTANT]
====
Only disable *Use compatibility mode* if VirtIO drivers are already installed in the source VM. VMs without pre-installed VirtIO drivers will fail to boot on {virt} if you disable compatibility mode.
====
*** Click *Save*.

.. *VM target node selector*, *VM target labels*, and *VM target affinity rules* are options that support VM target scheduling, a feature that lets you direct {project-short} to migrate virtual machines (VMs) to specific nodes or workloads (pods) of {virt} as well as to schedule when to power on the VMs.
+
For more information on the feature in general, see link:{mtv-mig}assembly_advanced-migration-options_mtv#target-vm-scheduling-options_mtv[Target VM scheduling options].
+
For more details on using the feature with the UI, see link:{mtv-mig}assembly_advanced-migration-options_mtv#configuring-target-vm-scheduling-ui_mtv[Scheduling target VMs from the user interface].

* *VM target node selector* allows you to create mandatory exact match key-value label pairs that the target node must possess. If no node on the cluster has all the labels specified, the VM is not scheduled and it remains in a `Pending` state until there is space on a node that fits these key-value label pairs.

** To use the VM target node selector for your migration plan, do the following:
*** Click the *Edit* icon.
*** Enter a key-value label pair. For example, to require that all VMs in the plan be migrated to your `east` data center, enter `dataCenter` as your *key* and `east` as your *label*.
*** To add another key-value label pair, click *+* and enter another key-value pair.
*** Click *Save*.

* *VM target labels* allows you to apply organizational or operational labels to migrated VMs for identification and management. One use for these labels is to use them to specify a different scheduler for your migrated VMs, by creating a specific target VM label for it.

** To use the VM target node selector for your migration plan, do the following:
*** Click the *Edit* icon.
*** Enter one or more VM target labels.
*** Click *Save*.

* *VM target affinity rules*: Target affinity rules let you use conditions to either require or prefer scheduling on specific nodes or workloads (pods).
+
Target anti-affinity rules let you prevent VMs from being scheduled to run on selected workloads (pods) or prefer that they are not scheduled. These kind of rules offer more flexible placement control than rigid Node Selector rules, because they support conditionals such as `In`, or `NotIn`.
+
For example, you could require that a VM be powered on "only if it is migrated to node A _or_ if it is migrated to an SSD disk, but it _cannot_ be migrated to a node for which `license-tier=silver` is true."
+
Additionally, both target affinity and target anti-affinity rules allow you to include both _hard_ and _soft_ conditions in the same rule. A hard condition is a requirement, and a soft condition is a preference. The previous example used only hard conditions. A rule that states that "a VM can be powered on if it is migrated to node A _or_ if it is migrated to an SSD disk, but it is preferred not to migrate it to a node for which `license-tier=silver` is true" is an example of a rule that uses soft conditions.
+
{project-short} supports target affinity rules at both the node level and the workload (pod) level. It supports anti-affinity rules at the workload (pod) level only.

** To use VM target affinity rules for your migration plan, do the following:
*** Click the *Edit* icon.
*** Click *Add affinity rule*.
*** Select the *Type* of affinity rule from the list. Valid options: Node Affinity, Workload (pod) Affinity, Workload (pod) Anti-Affinity.
*** Select the *Condition* rom the list. Valid options: Preferred during scheduling (soft condition), Required  during scheduling (hard condition).
*** Soft condition only: Enter a numerical *Weight*. The higher the weight, the stronger the preference. Valid options: whole numbers from 1-100.
*** Enter a *Typology key*, the key for the node label that the system uses to denote the domain.
*** Optional: Select the *Workload labels* that you want to set by doing the following:
**** Enter a *Key*.
**** Select an *Operator* from the list. Valid options: `Exists`, `DoesNotExist`, `In`, and `NotIn`.
**** Enter a *Value*.
*** To add another label, click *Add expression* and add another key-value pair with an operator.
*** Click *Save affinity rule*.
*** To add another affinity rule, click *Add affinity rule*. Rules with a preferred condition will stack with an `AND` relation between them. Rules with a required condition will stack with an `OR` relation between them.
+
{project-short} validates any changes you made on this page.

. In addition to listing details based on your entries in the wizard, the *Plan details* tab includes the following two sections after the details of the plan:
+
* *Migration history*: Details about successful and unsuccessful attempts to run the plan
* *Conditions*: Any changes that need to be made to the plan so that it can run successfully
+
. When you have fixed all conditions listed, you can run your plan from the *Plans* page.
+
The *Plan details* page also includes five additional tabs, which are described in the table that follows:
+
[cols="1,1,1,1,1",options="header"]
.Tabs of the Plan details page
|===
|YAML
|Virtual Machines
|Resources
|Mappings
|Hooks

|Editable YAML `Plan` manifest based on your plan's details including source provider, network and storage maps, VMs, and any issues with your VMs
|The VMs the plan migrates
|Calculated resources: VMs, CPUs, and total memory for both total VMs and running VMs
|Editable specification of the network and storage maps used by your plan
|Updatable specification of the hooks used by your plan, if any
|===
